# Constructor 를 이용한 Class 선언

Dart 에서 생성자를 정의할 때는 <R>클래스 이름과 동일한 메서드</R>를 만들면 됩니다. 이때 **반환 타입은 따로 작성하지 않**습니다.

생성자를 이용해서 멤버 변수를 초기화하려면, Dart의 **null-safety** 기능 때문에 **바로 초기화를 하지 않은 상태**에서는 **에러가 발생**해요. `int x` 는 `null` 을 허용하지 않기 때문입니다.

이런 경우에는 `late` 키워드를 사용하면, **나중에 생성자에서 초기화하겠다는 의도를 Dart에게 알려줄 수 있**습니다. 그리고 변수를 수정할 일이 없다면, `final` 키워드를 함께 사용해주는 게 좋아요.

TODO: 또, 맴버변수와 지역변수가 같은 이름을 가질 경우, `this` 를 사용해야 합니다.

```dart:Constructor
class Point {
    late final int x;
    late final int y;

    Point(x, y) {
        // 이 경우에는 this가 필요
        this.x = x;
        this.y = y;
    }

    void print_area() => print('Area: ${x * y}');
}

void main() {
    Point p = Point(5, 5);
    p.print_area();

    p = new Point(10, 10);
    p.print_area();
}
```

# 축약 문법

위 코드처럼 `this.x = x` 로 멤버 변수를 초기화하는 패턴은 매우 흔하게 사용되기 때문에, 이걸 간단하게 **줄여 쓸 수 있는 문법**을 제공합니다.
```dart:축약-문법
class Point {
  late final int x;
  late final int y;

  Point(this.x, this.y);

  void print_area() => print('Area: ${x * y}');
}
```
위 코드는 바로 전 코드와 **동일하게 동작**합니다. 훨씬 간결하죠?


# Named Parameters

Dart에서는 생성자에 **Named Parameters**도 사용할 수 있습니다. 이 방식은 파라미터의 순서를 신경 쓰지 않아도 되기 때문에 실수를 줄일 수 있어요.

단, **Named Parameters** 는 기본적으로 **nullable** 이기 때문에 `required` 키워드를 사용해서 반드시 값을 전달하도록 설정해줘야 **null-safety** 를 지킬 수 있습니다.


```dart:Named-Parameters
class Point {
    late final int x;
    late final int y;

    Point({
        required this.x,
        required this.y,
    });

    void print_area() => print('Area: ${x * y}');
}
```

# Named Constructor

가끔 Class 에 <R>여러 종류의 생성자</R>가 필요할 때가 있어요. 이럴 때 Dart 에서는 **Named Constructor** 를 사용할 수 있습니다.

TODO: 아래 예제에서는 `Point` 클래스에 `fix` 라는 이름의 생성자를 추가한 경우입니다. Method 를 사용하는것처럼 Class 명과 `.` 을 사용해 선언하면 됩니다. 사용할때도 `new Point().fix()` 처럼 마치 Method 처럼 쓸 수 있습니다.

이렇게 하면 `Point` 클래스는 기본 생성자와 `fix` 생성자 <R>두 가지를 가질 수 있</R>어요.


```dart:Named-Constructor
class Point {
    late final int x;
    late final int y;

    Point({
        required this.x,
        required this.y
    });

    Point.fix({this.x = 10, this.y = 10});

    void print_area() => print('Area: ${x * y}');
}

void main() {
    Point p = new Point(x: 5, y: 5);
    p.print_area();

    p = new Point.fix();
    p.print_area();
}
```
```dart:class
class Point {
    int x = 10;
    int y = 10;

    void print_area() => print('Area: ${x * y}');
}

void main() {
    Point p = new Point();
    p.print_area();

    p = new Point().fix();
    p.print_area();
}
```

# Constant Constructor

Dart 에서는 Class 를 `const` 로 선언할수 있습니다. 그러기 위해선 몇가지 제약이 있습니다.

* 모든 멤버 변수는 `final` 이여야 함
* Constructor 앞에 `const` 키워드를 붙여야 함

이렇게 하면 프로그램이 실행되기 전에 미리 값이 고정되기 때문에 메모리도 절약되고, 코드도 더 안전해질 수 있어요. 그리고 이전에 const 에서 말했듯 같은 값은 한 메모리만 공유하기 때문에 메모리 절약 효과도 볼수 있습니다.

```dart:Constant-Constructor
class ImmutablePoint {
    final double x, y;

    const ImmutablePoint(this.x, this.y);
}

void main() {
    const p1 = ImmutablePoint(1.0, 2.0);
    const p2 = ImmutablePoint(1.0, 2.0);

    print(identical(p1, p2));   // true
    print(p1 == p2);            // true
}
```

위 코드는 const 로 생성된 두 instance 가 서로 동일한 메모리를 가리키고 있음을 보여줍니다. `identical()` 메서드는 두 객체가 동일한 메모리를 가리키고 있는지 확인하는 메서드입니다.

여기서 주의할점은 const 생성자가 있다고 해서 항상 상수 객체가 만들어 지는것은 아닙니다. 반드시 const 키워드로 인스턴스를 생성할 때만 상수가 됩니다.

# Redirecting Constructor [생성자 위임]

가끔 클래스 안에서 다른 생성자에게 일을 넘기고 싶을 때가 있어요. 이럴 때 Dart에서는 Redirecting Constructor (생성자 위임) 문법을 제공합니다.
