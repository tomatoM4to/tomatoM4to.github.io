이 이후론 관리자의 역할, 윈도우도 관리자 권한 실행 있는것처럼

학부수준에선 심도있게 하긴 어려움, 그래도 이정도만 알아도 기본은 함

DB 내부 구조까지 알아야 어느정도 알 수 있음, 그래도 매우 중요한 부분

# Transaction
번역하면 거래로 DBMS 에서 데이터를 다루는 논리적 작업의 단위

SELECT 에선 별로 일어날일 없는데 DELETE, UPDATE 할땐 자주 이런게 필요

DB에서 항상 중요하게 생각하는게 장애가 일어날 경우를 상정함

그리고 동시성도 매우 중요, 컴퓨터 공학과 학생이라면 공유자원 문제에 대해 알고 잇을 것, 그래서 작업을 서로 분리하는 단위가 돼기도 함

## 트랜잭션 개념

start transaction 내부에선 업데이트 하기 위한 테이블들을 미리 읽어오게 된다. COMMIT 이 완료 돼어도 버퍼 내부에 변경된 데이터가 실제 DB에 언제 들어갈진 알수 없다. 실제로는 COMMIT 돼도 나중에 들어갈 수 있음

1 - 2 - 3 - 4 - COMMIT - 5 -6

5번 6번이 실제 DB에 올라가는것

왜 이런 방법을 쓰지?

버퍼에 있는 내용을 DB에 집어넣는 과정은 매우 시간이 걸리는 작업, 그리고 1번 사용자, 2번 사용자 순차적으로 저장이 돼서 나중에 저장, 왜냐하면 버퍼에 있는 내용을 다시 쓸수도 있으니, 캐싱으로도 쓸수 있음

COMMI: 개념상 트랜잭션 완료지만 실제 동작은 부분 완료, DBMS에 내부적으로 빈시간이다 판단하면 버퍼의 내용을 실제 DB(disk)에 기록, 그래서 부분 완료라 그럼


***

# 트랜잭션의 성질, ACID

## 원자성(all or nothing)
쪼개면 안됨, 가장 중요

## Consistency(일관성)
뒤에 설명

## 고립성(Isolation)
DB는 여러 사람이 사용, 즉 여러 트랜잭션이 존재

## 지속성

***

# 원자성(Atomicty)
easy

`SAVEPOINT` 개념은 다시 알아바야 할수도, 프로그래밍에서 jump를 자주 쓰면 안좋듯 ROlLBACK,SAVEPOINT는  가능하면 줄이는게 안전

# 일관성
추후 엄청 자세하게 하겠지만 일단 이정도

예제에서 나오듯 이전 이후의 sum이 같아야 한다는게 아니라, 이치에 맞아야함, 우리의 의도가 둘다 정확해야함

CREATE TABLE 할때 어느 속성은 0 이상이여야 하고.. 등, 무결성 제약조건도 사실 일관성을 위한 작업이라 할 수 있음

# 고립성(Isolation)
overwrite 방지, 트랜잭션 통제

DBMS를 마치 나 혼자 쓰는것처럼 느껴져야 함, DBMS가 해주지

# 지속성
부분 완료 후 버퍼내용을 disk에 기록해야 하는데 부분완료 돼었지만 disk에 기록이 안됄수도 있음(실패)

***

여기까지가 개념

***

# 동시성 제아(en)
여서부터 복잡

DBMS 내부의 기능중 하나

트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는기능

TODO: 동시성 제어 개념표 필요

표
* 트랜잭션 2개 존재 가정
* 서로 상관없는 테이블을 활용하면 상관없음, 하지만 같은 테이블이면 문제
* 읽기, 읽기: 아무 상관 없음
* 일기, 쓰기: 읽어간데이터를 누군가 쓰면 읽어간 데이터아 달라질수 있음
  * 케이스가 3개 존재, 허용/불가 중 선택, 옵션임, 나중에 자세히 함
* 쓰기, 쓰기: 가장 긴급한 상황, 어떤 트랜잭션이 쓴 내용이 없어지는 갱싱 손실 발생, 허용불가(LOCK) 필요

## 갱신 손실(lost update)
같은 데이터를 여러 트랜잭션이 쓰려고 하는 상황

같은 테이블의 같은 속성일수도 같은 튜플일수도 있음

**EXAMPLE**
* 트랜잭션 T1, T2
  * T1은 예금을 인출(UPDATE) 하는 작업
  * T2는 입금(UPDATE) 하는 작업
* T1은 계좌 x에서 100을 빼고, T2는 계좌 x에 100을 더함
  * 서로의 트랜잭션을 서로 DB에 요청해서 재수없게 딱 걸린 상황
* 초기에 x의 값이 1000이라면 T1 -) t2 혹은 T2 -) T1 어느 순서로 실행해도  결과는 x = 1000
* 이 경우 일관성의 조건은 어떤 경우라도 x의 값이 1000 이여야 하는것

**내부 시나리오**

TODO: 표 다시 써야함

1. A = read(x) # 버퍼의 데이터 값 x = 1000
2. A = A - 100 # 이 순간 스위칭 발생
  1. B = read(x)
  2. B = B + 100 # 버퍼의 데이터 값 = 1000
3. write(A -> x) x = 900
  3. write(B -> x) x = 1100

이 때문에 Lock이라는 개념이 등장, 운영체제의 임계영역, 세마포어랑 비슷한 개념

사실 Network랑 별 상관 없음, target netweork라 말하지만 사실 펑션 어프로시 메이트로 고정시키는 방법과똑같, 사용한 network는ㄴ 이미지 처리를 위한 네트워크 하나