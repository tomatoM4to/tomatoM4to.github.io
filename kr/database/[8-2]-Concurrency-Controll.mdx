# 동시성 제어
트랜잭션 여러개가 돌아가는데 서로 같은데이터를 참조할때 일관성을 해치지 않도록트랜잭션

트론잭션을 어떻게보면 process라 볼수 있음

## 쓰기 쓰기: 락
세마포어와 거의 같은 개념

쓸려고 할때 내 데이터에 자물쇠를 잠가버리고 키를 안주고 쓴다음 풀고 다른사람에게 키를 줌

키 관리는 DBMS의 역할

이것이 락의 기본 개념

### example
TODO: 예시 테이블 작성

엄밀하겐 T1이 끝나고 T2가 시작돼진 않고 왔다갔다 하면서 스케줄을 맞쳐준다? 뭔소리지

일관성과 고립성을 확실히 지켜질수 있음

80년대 90년대 동시성을 제어하기 위한 여러 방법이 재시돼었지만 락이 가장 대표적이고 오라클도 락을 사용

실제 트랜잭션에선 락이 존재하기 때문에 한 트랜잭션을 만들때는 시간이 최대한 덜걸리게 해야 한다. select 같은건 쓰면 안됨


이로서 쓰기 쓰기 문제 해결

## 락의 유형
공유략, 배타락이 존재

이전에 에기했던건 배타락이라 그럼, LX 상태라면 LS, LX 요청에 의한 읽고, 쓰기를 전부 차단, 원래 이렇게 하는게 맞음

근데 이렇게 하드한 락을 걸어놓니 성능 문제가 발생

그래서 LS 락이 존재, LS 락에선 읽기를 허용함, 동시성을 높이기 위한 트레이드 오프, LS락은 읽는 락임, 읽느 요청을 하면 LS 락을 검, ls락에서도 쓰기는 차단됨

동시성을 위해 읽는락, 쓰기락을 나눠서 처리함

## 2단계 락킹
락을 사용하되 2단계 락킹 기법을 사용하지 않을경우 발생할수 있는 문제

TODO: 아니 가운데 의사 코드에서 왜 락이 저절로 풀어져?

솔루션: 트랜젝션이 끝날때 락을 품;;모  여러개 락을 가질순 있지만 이먼

TODO: 테이블 필요

## 데드락
쓰기쓰기 문제에서 생기는 문제

Os에서의 데드락이 그대로 나온거임

Todo: table example

누굴 하날 죽이는것밖에 답이 없음

누구 때문에 교착상태가 발생한지 모르기 대문에 둘중 하나가 죽음, 죽엇다는것은 롤백 됀다는 뜻임, 나머지 한쪼근 교착상태가 있는주 모르고계속 실행, 죽은애를 다시 실행해주는 기능은 없음

지금까지 한게 쓰기쓰기임

***

락이란건 기본적으로 동시성을 해치는 행위, 극단적으로 해석하면 동시성 생각 안하고 q에 놔서 선입선출 하면 됨

쓰기 읽기 시작

# dirty read(오손 읽기)
* T1: 읽기
* T2: 쓰기

실제 내부적으로 실행되는 예시

T2가 갑자기 무슨 일이 생겨서 롤백됏을때 예시, 이 예시는 30이 맞는 데이터고 21이 틀린 데이터, T2가 21로 수정하다 틀린 데이터라 롤백했지만 T1이 틀린데이터인 21을 읽어들인 상황

TODO: 예시 table 필요

근데 이런 생각 할수도 있음, 굳이 막아야 할까? 개발자가 상관 없으니 ㄱㅊ다! 할수도 있는데, 군사목적 같이 무조건 맞아야 한다면 어떨까?

## 반복불가능 읽기
내부적으로 T1은 읽고 T2는 업데이트 함 그리고 커밋 함, 그리고 T1이 다시 읽음, 이런 상황 가정

T1은 2번 읽는데 처음 읽는것과 두번째 읽은게 다름, 어떻게 보면 논리적으로 정상적인 상황일수도 있음

이또한 문제가 된다면 막아야 함

위는 ROLLBACK이 문제라면 이번엔 COMMIT 때문에 문제 발생

## 유령 데이터 읽기
T1은 읽고 T2가 INSERT 하는 상황, 이후 T1이 다시 읽을시 생기는 상황

처음 읽을때의 결과와 두번째읽을때 결과의 튜플의개수가 다름

유령같이생겨서 팬텀

위 가지는 저부 고립성이 깨진 상황

위 3가지는 절대적인게 아님, 허용 할수도 있음, 쓰기 쓰기 는 절대임!

***

# 막기 위한 방법
## 트랜잭션 고립 수준명령어
이전엔 시작과 끝만 선언했다면 이제 추가적인 명령어 써야함

TODO: 표 필요

근데 이론적으론 이런데 오라클은 2가ㅣ만 지원함, DB마다 다름

LEVEL READ UNCOMMITTEd 를 선언하면 돼야 하지만 오라클이 지원 안함

아무것도 안붙이면 처음 빨간거

***

어떻게 막았을까? 제일 어려운 예기

# Read UNCIMMITTED, LEVER = 0
읽기 할때 아무런 락을 안걸음

그 이후 쓰기가 락을걸고 수정을 하고 다시 읽기를 함

읽는게  아무런락 을 걸지 않았기에 T2가 맘대로 사용 가능

# READ COMMITTEd
읽기 할시 공유럭을 검 끝나면 바로 해지

첫번째 읽기시 락 걸고 푼다음 쓰기 다시 두번째 읽기 시 공유락을 다시 검,쓰기를 위한 T2는 베타락을 거는건 당연

이전표를보면 쓰기를 할시 누가 읽기락을 걸어놓고 있으면 대기하게 됨

OS의 스케줄링과 비슷함

T2가 롤벨해도 전혀 상관 없음

# 레벨 2
읽시 시 공유락 걸고 끝날때 까지 유지

위와 무슨 차이? 락을 최대한 안걸기 위한 노력임

# 시리얼라이즈
아주 강력

역시 읽기가 문제, 공유락을 걸고 트랜잭션 끝까지 유지, 이건 위와는 독같음

베타락 설정한ㄴ것도똑같음

인서트 문이라 발생하는 문제임

다른건

인덱스에 공유락을 검

좀 어려운 예기긴 한데..

일단 읽기 쓰기 읽기 할시 T1은 끝날때까지  LS 를 검

인서트하는 튜플은없는 객체기 때문에 Lx를 걸수가 없음

예전에 봤는데 각 튜플을 가리키는 인덱스 라는 개념을 말했음, 도한 PK는  자동으로 인덱스가 붙음

그리고 이러한 인덱스는 물리적인 파일로디스크에 저장되어 있음

여기ㅓ 예기 하고자 하는 예기는 새로운 튜플을 인서트할시 해당 테이블에만 인서트 하냐? 아님 인덱스에도 추가해야함

그래서 여기서 말하고자 하는건 이 인덱스에 공유락을 걸어버리는거임, 이렇게 하면 INSERT 는 INDEX를 건드려야하는데 인덱스 파일자체에락이 걸려있으니 대기가 발생, 언제까지?

T1이 커밋이 될때까지

인덱스가 뒤로 밀린다? 뭔 말이지

락킹 말고도 여러 방법이 고안돼었긴 했는데 살아남은건 락킹이 거의 유일하다 보면 됨

근데 락을 쓰면 데드락이 발생할 수 있음

***

# 실험
