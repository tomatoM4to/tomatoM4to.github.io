# Q-learning
먼저 Q-learning라는 알고리즘이 어떻게 동작하는지 살펴보면서 강화학습이란것이 어떤식으로 작동하는지 살펴보겠 습니다. $4*4$ 격자 지도가 있다 가정해 보겠습니다. $(0, 0)$ 에서 출발해 $(3, 3)$에 도착해야 한다 가정해 보겠습니다.

이 지도를 처음부터 전부 알고 있다면 한번에 가장 빠른 길을 찾을 수 있겠지만, RL에선 보통 이 지도를 모른다고 가정합니다. 때문에, 바로 최적의 길을 찾는것이 아니라 아래에도 가보고 위에도 가보고 하는 과정을 거치다가 우연히 $(3, 3)$에 도착하게 됩니다. 그러면서 이 경로를 점점 최적의 경로로 만들어 나가는 것이 RL의 핵심입니다. 핵심적인 부분은 지금 $(3, 3)$ 에 도착했다 라는 사실많을 알게 되는겁니다. 이렇게 하면 첫번째 episode가 끝나게 됩니다.

그리고 2번째, 3번째 episode를 거치면서 점점 최적의 경로를 찾아나가게 됩니다. 이렇게 최적의 경로를 찾아나가는 과정을 Q-learning이라고 합니다. Q-learning은 이러한 과정을 통해 최적의 경로를 찾아나가는 알고리즘입니다.

## Greedy action
이러한 과정을 구현하기 위해 Q-learning에선 Greedy-action라는 행동을 합니다. 직역하면 탐욕적인 행동이라 할수 있는데요, 움직이는 각 경로마다 점수를 매기고 해당 점수가 가장 큰 방향으로 움직이는 것입니다.

1. 초기에 상하좌우로 이동할수 있는 격자지도는 $[0, 0, 0, 0]$ 으로 초기화 되어 있습니다. 각각 상하좌우에 대한 값입니다. 이때는 전부 점수가 같은 상황이니 Random하게 행동하게 됩니다. 각 방향에 대해 0.25의 확률로 움직이게 됩니다.

|  |  |  |  |
|---|---|---|---|
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | R = 1 |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |


2. 그러다가 우연히 $(3, 3)$에 도착하게 된다면, Q-learning는 이곳에 무엇인가 있어! 라면서 헨젤과 그레텔처럼 무엇인가를 남기고 episode를 끝내게 됩니다. 이때는 위로 가는 방향에 대해 점수를 R로 매기게 됩니다. R은 Reward의 약자로 정수의 형태로 존재합니다. 그 이외인 좌, 우, 아래 방향에 대해는 아직 0점입니다.

|  |  |  |  |
|---|---|---|---|
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | R = 1 |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [R, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |

3. 2번째 episode를 시작합니다. 이번에도 아직 $(3, 1)$ 에서 위로가는 방향에 대한 점수많이 R이고 그 이외의 나머지는 아직 0인 상태입니다. 그러다가 우연히 $(2, 1)$ 번째 좌표에 들려 또 우연히 오른쪽으로 이동했다 가정해 보겠습니다. 이렇게 되면 Q-learning는 0이 아닌 더 큰 값을 발견하게 됩니다. 이때 Q-learning는 $(3, 1)$의 가장 큰값을 $(2, 1)$에 매기게 됩니다. 이때는 $(2, 1)$에서 오른쪽으로 가는 방향에 대해 점수를 R로 매기게 됩니다. Q-learning의 중요한 특징을 여기서 관찰할수 있는데요, Q-learning은 이동을 하면서 바로바로 업데이트 합니다. 그렇기 때문에 에피소드가 끝나기 전에도 업데이트를 수행 합니다. 오른쪽으로 이동을 함과 동시에 오른쪽으로 갔을때의 형가를 실시간으로 업데이트 합니다. 이렇든 이 판을 만드는 과정이 Q-learning이고 이러한 값을 Q-value라고 합니다.

|  |  |  |  |
|---|---|---|---|
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | R = 1 |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, R] | [R, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |

4. 이런식으로 episode를 지속한다면 최종적으로 이러한 방향이 나오게 됩니다.

|  |  |  |  |
|---|---|---|---|
| [0, R, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | R = 1 |
| [0, 0, 0, R] | [0, 0, 0, R] | [0, 0, 0, R] | [R, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |

### 구현
```python
import random
import copy

def greedy_q_learning():
    # 4x4 맵 초기화, 각 위치마다 4개의 행동(상,하,좌,우)에 대한 Q값
    map = [[[0, 0, 0, 0] for _ in range(4)] for _ in range(4)]

    # 목표 지점의 Q값을 99로 설정
    map[3][3] = [99, 99, 99, 99]
    count = 0
    for episode in range(1000):
        state = [0, 0]  # 시작 위치
        cp_map = copy.deepcopy(map)  # 맵 변화 감지를 위한 복사

        while state != [3, 3]:  # 목표 도달까지 반복
            loc = map[state[0]][state[1]]

            # 현재 위치에서의 행동 선택
            if loc.count(0) == 4:  # 모든 Q값이 0이면 랜덤 선택
                action = random.randint(0, 3)
            else:  # 가장 큰 Q값을 가진 행동 선택
                action = loc.index(max(loc))

            # 이전 상태 저장
            prev_state = copy.deepcopy(state)

            # 선택한 행동으로 이동
            if action == 0 and state[0] > 0:  # 상
                state[0] -= 1
            elif action == 1 and state[0] < 3:  # 하
                state[0] += 1
            elif action == 2 and state[1] > 0:  # 좌
                state[1] -= 1
            elif action == 3 and state[1] < 3:  # 우
                state[1] += 1

            # 맵 밖으로 나가는 경우 처리
            if state[0] < 0:
                state[0] = 0
            elif state[0] > 3:
                state[0] = 3
            if state[1] < 0:
                state[1] = 0
            elif state[1] > 3:
                state[1] = 3

            # Q값 업데이트: Q값을 그대로 전파 함으로써, 한번 설정된 경로를 게속 따라가게 됩니다
            next_q_values = map[state[0]][state[1]]
            if max(next_q_values) > 0:
                map[prev_state[0]][prev_state[1]][action] = max(next_q_values)

            # 목표 도달 시
            if state == [3, 3]:
                map[prev_state[0]][prev_state[1]][action] = 99
                break

        # 맵이 변화하지 않을시 카운트
        if map == cp_map:
            count += 1
    return map, count

# 실행
q_map, count = greedy_q_learning()

# 결과 출력
print("Final Q-values:")
for row in q_map:
    print(row)

print("Count:", count)
```

***

하지만 이러한 문제가 있습니다. 이렇게 경로를 찾아나가는 과정을 거치다 보면, 도착은 할수 있겠지만 이 경로가 최적의 경로가 아닐 확률이 매우 높습니다. 또한 최적이 아닌 경로를 계속 따라가게 됩니다. 해당 코드의 count 변수의 값을 보면 경로를 찾은 뒤에도 계속 같은 경로로 이동하는 모습을 볼수 있습니다. 이러한 문제를 해결하기 위해 Q-learning에선 $\epsilon$-greedy action을 사용합니다.

# $\epsilon$-greedy action
greedy 방식에선 같은 경로를 계속 따라가게 되는 문제가 있습니다. 이를 해결하기 위해 탐험(Exploration) 이라는 개념을 도입한 방법입니다. 탐험이란 간단히 말해, 더 좋은길이 있을지도 모르니까 가보는 것입니다. 이제 탐험을 하기 위해 $\epsilon$-greedy action을 배워봅시다.

$\epsilon$이 무엇이냐면 0과 1 사이의 값을 의미합니다. 대충 0.1이라 가정해 보겠습니다. 이때 $\epsilon$-greedy action은 90%의 확률로 가장 큰 값을 가진 방향으로 이동하고, 10%의 확률로 랜덤하게 이동하는 것입니다. 이렇게 하면 랜덤하게 이동하면서 더 좋은 길이 있을지도 모르니까 가보는 것입니다.

만약 $\epsilon$ 이 1이라면? 100%의 확률로 랜덤하게 이동하게 됩니다. 이렇게 돼면, 기존에 찾았던 경로를 기반으로 더 좋은길을 유도 해줘야 하는데 유도해주지 못하는 상황이 발생합니다. 이렇듯 너무 높은 $\epsilon$값은 문제가 될수 있습니다. 반대로 너무 낮은 $\epsilon$값은 탐험을 하지 않아 최적의 경로를 찾지 못할수 있습니다. 이러한 $\epsilon$값을 조절하는 것이 중요합니다.

$\epsilon$ 을 이해했으니 이제 관련 용어를 알아보겠습니다. Exploration과 Exploitation입니다. Exploration은 탐험을 의미하고, Exploitation은 현재 가장 좋은 방향을 선택하는 것을 의미합니다. Exploitation은 Q값을 이용해 그리디하게 움직인단 의미이기도 합니다.

역시 Exploration과 Exploitation은은 trade-off 관계입니다. Exploration을 많이 하면 더 좋은 길을 찾을수 있지만, 그만큼 시간이 오래 걸립니다. 반대로 Exploitation을 많이 하면 빠르게 최적의 경로를 찾을수 있지만, 그만큼 더 좋은 길을 찾지 못할수 있습니다. 이러한 trade-off 관계를 잘 조절하는 것이 중요합니다.

Exploration의 두가지 장점
* 새로운 path 찾기 가능
* 새로운 goal 찾기 가능
    * 강화학습에선 map의 상태를 알지 못한다 했습니다. 기존엔 간단한 예시를 위해 한곳에 goal을 두었지만 실제로는 여러곳에 더 좋은 goal이 있을수 있습니다. 이때 탐험을 통해 새로운 goal을 찾을수 있습니다.

하지만 너무 탐험만 한다면 판때기를 이용하지 못합니다.

## Decaying $\epsilon$-greedy action
한번 생각해 봅시다. 그 어떤 정보도 없다면, 탐험을 하는게 좋을까요 아니면 Exploitation을 하는게 좋을까요? 보통 탐험을 하는것이 좋습니다. 그러나 탐험을 너무 많이 한다면, 최적의 경로를 찾지 못할수 있습니다. 하지만 이 두개는 trade-off 관계이디고 합니다. 이 전에는 $\epsilon$을 고정된 값으로 사용했지만, 이번에는 $\epsilon$을 점점 줄여가는 방법을 사용해보겠습니다. 이를 Decaying $\epsilon$이라고 합니다. 단순히 말해 처음엔 탐험을 많이 하다 나중엔 최적화에 더 많은 비중을 두는 것입니다.

<R>이떄 줄여나가는 기준은 episode를 기준으로 합니다.</R> 이 방식은 Q-learning에서 많이 사용되는 방법입니다. 그러므로써 trade-off 관계를 잘 조절할수 있습니다.

### 구현
```python
import random
import copy

def decaying_epsilon_greedy_q_learning():
    # 6x6 맵 초기화
    map = [[[0, 0, 0, 0] for _ in range(6)] for _ in range(6)]

    # 두 개의 도착 지점 설정 (첫 번째: [3,3]=10, 두 번째: [5,5]=20)
    map[3][3] = [10, 10, 10, 10]  # 첫 번째 도착지점
    map[5][5] = [20, 20, 20, 20]  # 두 번째 도착지점 (더 큰 보상)

    # Epsilon 파라미터
    epsilon_start = 0.9
    epsilon_end = 0.01
    epsilon_decay = 0.995

    count = 0
    for episode in range(1000):
        state = [0, 0]  # 시작 위치
        cp_map = copy.deepcopy(map)

        # 현재 에피소드의 입실론 값 계산
        epsilon = max(epsilon_end, epsilon_start * (epsilon_decay ** episode))

        # 도착지점에 도달할 때까지 반복
        while state != [3,3] and state != [5,5]:
            loc = map[state[0]][state[1]]

            # Epsilon-greedy 행동 선택
            if random.random() < epsilon:
                action = random.randint(0, 3)
            else:
                action = loc.index(max(loc))

            prev_state = copy.deepcopy(state)

            # 행동 실행
            if action == 0 and state[0] > 0:    # 상
                state[0] -= 1
            elif action == 1 and state[0] < 5:  # 하 (범위를 5로 변경)
                state[0] += 1
            elif action == 2 and state[1] > 0:  # 좌
                state[1] -= 1
            elif action == 3 and state[1] < 5:  # 우 (범위를 5로 변경)
                state[1] += 1

            # 경계 처리
            state[0] = max(0, min(state[0], 5))
            state[1] = max(0, min(state[1], 5))

            # Q값 업데이트
            next_q_values = map[state[0]][state[1]]
            if max(next_q_values) > 0:
                map[prev_state[0]][prev_state[1]][action] = max(next_q_values) - 1

            # 도착지점 도달시
            if state == [3, 3]:
                map[prev_state[0]][prev_state[1]][action] = 9  # 첫 번째 도착지점 직전
                break
            elif state == [5, 5]:
                map[prev_state[0]][prev_state[1]][action] = 19  # 두 번째 도착지점 직전
                break

        # 맵이 변화하지 않을시 카운트
        if map == cp_map:
            count += 1

    return map, count

# 실행
q_map, count = decaying_epsilon_greedy_q_learning()

# 결과 출력
print("Final Q-values:")
for row in q_map:
    print(row)
print("\nCount:", count)

# 최적 경로 출력
def print_optimal_path():
    state = [0, 0]
    path = [(0, 0)]

    # 두 도착지점 중 하나에 도달할 때까지
    while state != [3,3] and state != [5,5]:
        loc = q_map[state[0]][state[1]]
        action = loc.index(max(loc))

        if action == 0:    # 상
            state[0] -= 1
        elif action == 1:  # 하
            state[0] += 1
        elif action == 2:  # 좌
            state[1] -= 1
        elif action == 3:  # 우
            state[1] += 1

        state[0] = max(0, min(state[0], 5))
        state[1] = max(0, min(state[1], 5))
        path.append((state[0], state[1]))

    print("\nOptimal path:", path)
    print("Final destination:", state)

print_optimal_path()
```
이전관 다르게 6x6으로 확장되었고, 두개의 도착지점이 추가되었습니다. 이때 첫번째 도착지점은 10점, 두번째 도착지점은 20점을 가지고 있습니다. 이때 두번째 도착지점이 더 높은 점수를 가지고 있습니다. 그리고 경로를 추적하는 코드가 추가되었습니다.

## Discount factor
위 예제에서 어느정도 구현이 됐었습니다. Discount factor은 결국 더 효율적이게 path를 찾기 위해 고안된 방법입니다. 코드가 아니라 아까 배웠던 이론을 생각해 봅시다. 우린 이때까지 다음상태의 최대값을 현재상태에 업데이트 했습니다. 근데 이건 뭔가 이상합니다. 상하좌우로 움직일때 더 좋고 안좋고가 없이 무조건 같은 값으로 업데이트를 한다고 이론적으로 학습했습니다. Discount factor은 이러한 문제를 해결하기 위해 고안된 방법입니다.

Discount factor 은 기호로 $\gamma$로 표현합니다. 이는 0과 1사이의 값을 가집니다. 이는 상태를 업데이트 할때 다음 상태의 최대값 $\gamma$을 곱해줍니다. 이는 다음 상태의 최대값을 현재 상태에 업데이트 할때 그 값이 얼마나 중요한지를 나타냅니다. 이를 통해 더 효율적인 path를 찾을수 있습니다.

처음엔 그대로 복사를 합니다. 하지만 그 다음 업데이트 할때는 $\gamma$를 곱해 업데이트 해라! 라는 겁니다.

한번 위 4x4 예제로 살펴보겠습니다.
|  |  |  |  |
|---|---|---|---|
| [0, $R\gamma^4$, 0, $R\gamma^2$] | [0, 0, 0, $R\gamma$] | [0, 0, 0, $R$] | $R$ |
| [0, 0, 0, $R\gamma^3$] | [0, 0, 0, $R\gamma^2$] | [0, 0, 0, $R\gamma$] | [$R$, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |
| [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] | [0, 0, 0, 0] |

결과적으로 어떻게 될까요? 첫 시작점은 (0, 0)에서 가장 큰값인 $R\gamma^2$ 값을 가진 방향으로 나아가 결국 최적의 경로를 찾게 될것입니다.

### Discount factor 값에 따른 결과
한번 $\gamma$값이 작다고 가정해 보겠습니다. 그렇다면 위 그림에서 $R\gamma$으로 가야 $R$ 상태에 도달하지만, $R\gamma$이 작다면 $R$으로 가는것이 어려울수 있습니다. 하지만 $R$상태에선 아! 이방향으로 가면 보상이 기다리는구나! 라면서 확실히 이동할겁니다. 지금 당장 $R\gamma$ 로 가도.. 보상은 없겠지.. 한번더 움직여야 하잖아? 라고 생각하는것과 비슷합니다. 이걸 흔히 현재지향적인 행동이라고 합니다. 미래에 큰 보상이 있더라도 지금 당장 현재를 더 중요하게 생각하는겁니다.

반대로 $\gamma$값이 크다면? $R\gamma$으로 가는것을 더 중요하게 생각할겁니다. 현실로 대입해보면 더 가야할순 있을거 같은데 그래도 거의 다왔다! 라고 생각하고 그 방향으로 가는것과 비슷합니다. 호들갑을 떨면서 가는것이라고 생각하면 됩니다. 이러한 행동을 미래지향적인 행동이라고 합니다. 지금 현재 받을 보상보다 미래에 받을 보상을 더 중요하게 생각하는 효과가 생깁니다.

***

# Q-update
