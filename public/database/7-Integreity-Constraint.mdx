# 무결성 제약조건
무결성 제약조건은 데이터베이스의 일관성과 정확성을 유지하기 위해 적용되는 규칙들입니다. 이는 **결함이 없도록 붙여주는 조건**으로 이해할 수 있으며, 이러한 조건들은 SQL을 통해 정의할수 있습니다. 관리는 DBMS가 자동적으로 해주며, 모두 키와 밀접한 관련이 있습니다.

관계형 모델에서는 3가지 무결성 제약조건이 있습니다, 직관적으로 이해할수 있을만큼 간단하며, 관리자는 제약조건을 정의하는데 집중하면 됩니다.
1. 도메인 무결성 제약조건
    * 속성의 값이 특정 도메인에 속해야 한다는 조건입니다. 예를 들어, 학번은 정수여야 하며, 문자열이 될 수 없습니다.
2. 개체 무결성 제약조건
    * 테이블의 기본키를 지정해야 한다는 조건입니다.
3. 참조 무결성 제약조건
    * 관계에 관한 조건으로, 한 테이블의 외래키가 다른 테이블의 기본키를 참조할 때, 이 두 키의 타입이 같아야 한다는 조건입니다.


## 참조 무결성 제약조건 주요 동작
SQL로 테이블을 생성하기 전 중요한 고려사항이 있습니다. 예를들어 `CUSTOMER`테이블과 `ORDER`테이블이 있다 가정해 봅시다. 그리고 `ORDER`테이블은 `customer.id`를 **Foreign key**로 받는 속성이 있습니다. 이때 만약 어떤 고객이 계정을 삭제하면 다음과 같은 동작을 고려해야 합니다.

1. 이 고객과 관련된 주문도 삭제해야 할지
2. 디폴트 값으로 바꿔야 할지
3. 삭제를 막아야 할지

이러한 동작은 테이블을 생성할 때 결정할 수 있습니다. DBMS는 이러한 동작을 자동으로 처리해주므로, 관리자는 테이블을 설계, 생성할 때만 신경쓰면 됩니다.

### 부모 테이블과 자식 테이블


### INSERT
`CUSTOMER`테이블에 튜플을 추가할땐 제약조건이 없습니다. `ORDER`테이블에 **INSERT**할때는 `CUSTOMER`테이블이 현재 가지고 있는 키로 삽힙해야 합니다. 직관적으로 이해할 수 있으며, DBMS가 알아서 처리해줍니다.

### DELETE
**INSERT**와는 반대로 `CUSTOMER`테이블을 삭제할때는 문제가 되지만, `ORDER`테이블을 삭제할때는 문제가 되지 않습니다. 이때 `CUSTOMER`테이블을 삭제할때 어떻게 할지에 대한 정책이 필요합니다. 다음과 같은 정책이 있습니다.
1. **CASCADE**: `CUSTOMER`테이블의 특정 튜플을 삭제하면 `ORDER`테이블의 관련 튜플도 삭제
2. **SET NULL** 또는 **SET DEFAULT**: `CUSTOMER`테이블의 특정 튜플을 삭제하면 `ORDER`테이블의 관련 튜플을 디폴트 값으로 바꿈(예를들어 NULL)
3. **RESTRICT** 또는 **NO ACTION**: `CUSTOMER`테이블을 참조하는 `ORDER`테이블이 있으면 `CUSTOMER`테이블의 특정 튜플을 삭제할 수 없음

### UPDATE
UPDATE는 개념적으로 DELETE와 INSERT의 연속적인 작업으로 볼 수 있지만, 실제 동작은 더 복잡합니다. 부모 테이블(예: CUSTOMER)의 기본키를 업데이트할 때 다음과 같은 상황을 고려해야 합니다:

자식 테이블(예: ORDER)에 미치는 영향:

* ON UPDATE CASCADE: 부모 테이블의 기본키가 변경되면, 이를 참조하는 자식 테이블의 외래키도 자동으로 새 값으로 업데이트됩니다.
* ON UPDATE SET NULL: 부모 테이블의 기본키가 변경되면, 이를 참조하는 자식 테이블의 외래키는 NULL로 설정됩니다.
* ON UPDATE RESTRICT 또는 NO ACTION: 자식 테이블에서 참조하고 있는 부모 테이블의 기본키는 변경이 불가능합니다.


새로운 값의 유효성:

부모 테이블의 기본키를 새로운 값으로 변경할 때, 이 새로운 값은 기본키의 제약조건(유일성, NOT NULL 등)을 만족해야 합니다.


트랜잭션의 원자성:

UPDATE 작업은 하나의 트랜잭션으로 처리되므로, 부모 테이블의 변경과 그에 따른 자식 테이블의 변경이 모두 성공적으로 이루어지거나, 아니면 모두 취소되어야 합니다.

중요한 점은, UPDATE 작업이 실제로 부모 레코드를 삭제하고 새로 삽입하는 방식으로 수행되지 않는다는 것입니다. 대신, DBMS는 효율적인 방법으로 해당 레코드의 값을 직접 변경하고, 필요에 따라 관련된 자식 테이블의 레코드들을 처리합니다.