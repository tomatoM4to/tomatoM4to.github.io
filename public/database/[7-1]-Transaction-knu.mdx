이 이후론 관리자의 역할, 윈도우도 관리자 권한 실행 있는것처럼

학부수준에선 심도있게 하긴 어려움, 그래도 이정도만 알아도 기본은 함

DB 내부 구조까지 알아야 어느정도 알 수 있음, 그래도 매우 중요한 부분

# Transaction
번역하면 거래로 DBMS 에서 데이터를 다루는 논리적 작업의 단위

SELECT 에선 별로 일어날일 없는데 DELETE, UPDATE 할땐 자주 이런게 필요

DB에서 항상 중요하게 생각하는게 장애가 일어날 경우를 상정함

그리고 동시성도 매우 중요, 컴퓨터 공학과 학생이라면 공유자원 문제에 대해 알고 잇을 것, 그래서 작업을 서로 분리하는 단위가 돼기도 함

## 트랜잭션 개념

start transaction 내부에선 업데이트 하기 위한 테이블들을 미리 읽어오게 된다. COMMIT 이 완료 돼어도 버퍼 내부에 변경된 데이터가 실제 DB에 언제 들어갈진 알수 없다. 실제로는 COMMIT 돼도 나중에 들어갈 수 있음

1 - 2 - 3 - 4 - COMMIT - 5 -6

5번 6번이 실제 DB에 올라가는것

왜 이런 방법을 쓰지?

버퍼에 있는 내용을 DB에 집어넣는 과정은 매우 시간이 걸리는 작업, 그리고 1번 사용자, 2번 사용자 순차적으로 저장이 돼서 나중에 저장, 왜냐하면 버퍼에 있는 내용을 다시 쓸수도 있으니, 캐싱으로도 쓸수 있음

COMMI: 개념상 트랜젝션 완료지만 실제 동작은 부분 완료, DBMS에 내부적으로 빈시간이다 판단하면 버퍼의 내용을 실제 DB(disk)에 기록, 그래서 부분 완료라 그럼


***

# 트랜잭션의 성질, ACID

## 원자성(all or nothing)
쪼개면 안됨, 가장 중요

## Consistency(일관성)
뒤에 설명

## 고립성(Isolation)
DB는 여러 사람이 사용, 즉 여러 트랜잭션이 존재

## 지속성

***

# 원자성(Atomicty)
easy

`SAVEPOINT` 개념은 다시 알아바야 할수도, 프로그래밍에서 jump를 자주 쓰면 안좋듯 ROlLBACK,SAVEPOINT는  가능하면 줄이는게 안전

# 일관성
추후 엄청 자세하게 하겠지만 일단 이정도

예제에서 나오듯 이전 이후의 sum이 같아야 한다는게 아니라, 이치에 맞아야함, 우리의 의도가 둘다 정확해야함

CREATE TABLE 할때 어느 속성은 0 이상이여야 하고.. 등, 무결성 제약조건도 사실 일관성을 위한 작업이라 할 수 있음

# 고립성(Isolation)
overwrite 방지, 트랜잭션 통제

DBMS를 마치 나 혼자 쓰는것처럼 느껴져야 함, DBMS가 해주지

# 지속성
부분 완료 후 버퍼내용을 disk에 기록해야 하는데 부분완료 돼었지만 disk에 기록이 안됄수도 있음(실패)

***

여기까지가 개념

***

# 동시성 제아(en)
여서부터 복잡

DBMS 내부의 기능중 하나

트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는기능

TODO: 동시성 제어 개념표 필요

표
* 트랜잭션 2개 존재 가정
* 서로 상관없는 테이블을 활용하면 상관없음, 하지만 같은 테이블이면 문제
* 읽기, 읽기: 아무 상관 없음
* 일기, 쓰기: 읽어간데이터를 누군가 쓰면 읽어간 데이터아 달라질수 있음
  * 케이스가 3개 존재, 허용/불가 중 선택, 옵션임, 나중에 자세히 함
* 쓰기, 쓰기: 가장 긴급한 상황, 어떤 트랜잭션이 쓴 내용이 없어지는 갱싱 손실 발생, 허용불가(LOCK) 필요

## 갱신 손실(lost update)
같은 데이터를 여러 트랜잭션이 쓰려고 하는 상황

같은 테이블의 같은 속성일수도 같은 튜플일수도 있음

**EXAMPLE**
* 트랜잭션 T1, T2
  * T1은 예금을 인출(UPDATE) 하는 작업
  * T2는 입금(UPDATE) 하는 작업
* T1은 계좌 x에서 100을 빼고, T2는 계좌 x에 100을 더함
  * 서로의 트랜잭션을 서로 DB에 요청해서 재수없게 딱 걸린 상황
* 초기에 x의 값이 1000이라면 T1 -) t2 혹은 T2 -) T1 어느 순서로 실행해도  결과는 x = 1000
* 이 경우 일관성의 조건은 어떤 경우라도 x의 값이 1000 이여야 하는것

**내부 시나리오**

TODO: 표 다시 써야함

1. A = read(x) # 버퍼의 데이터 값 x = 1000
2. A = A - 100 # 이 순간 스위칭 발생
  1. B = read(x)
  2. B = B + 100 # 버퍼의 데이터 값 = 1000
3. write(A -> x) x = 900
  3. write(B -> x) x = 1100

이 때문에 Lock이라는 개념이 등장, 운영체제의 임계영역, 세마포어랑 비슷한 개념

사실 Network랑 별 상관 없음, target netweork라 말하지만 사실 펑션 어프로시 메이트로 고정시키는 방법과똑같, 사용한 network는ㄴ 이미지 처리를 위한 네트워크 하나

***

# 동시성 제어
트랜잭션 여러개가 돌아가는데 서로 같은데이터를 참조할때 일관성을 해치지 않도록트랜잭션

트론잭션을 어떻게보면 process라 볼수 있음

## 쓰기 쓰기: 락
세마포어와 거의 같은 개념

쓸려고 할때 내 데이터에 자물쇠를 잠가버리고 키를 안주고 쓴다음 풀고 다른사람에게 키를 줌

키 관리는 DBMS의 역할

이것이 락의 기본 개념

### example
TODO: 예시 테이블 작성

엄밀하겐 T1이 끝나고 T2가 시작돼진 않고 왔다갔다 하면서 스케줄을 맞쳐준다? 뭔소리지

일관성과 고립성을 확실히 지켜질수 있음

80년대 90년대 동시성을 제어하기 위한 여러 방법이 재시돼었지만 락이 가장 대표적이고 오라클도 락을 사용

실제 트랜잭션에선 락이 존재하기 때문에 한 트랜잭션을 만들때는 시간이 최대한 덜걸리게 해야 한다. select 같은건 쓰면 안됨


이로서 쓰기 쓰기 문제 해결

## 락의 유형
공유략, 배타락이 존재

이전에 에기했던건 배타락이라 그럼, LX 상태라면 LS, LX 요청에 의한 읽고, 쓰기를 전부 차단, 원래 이렇게 하는게 맞음

근데 이렇게 하드한 락을 걸어놓니 성능 문제가 발생

그래서 LS 락이 존재, LS 락에선 읽기를 허용함, 동시성을 높이기 위한 트레이드 오프, LS락은 읽는 락임, 읽느 요청을 하면 LS 락을 검, ls락에서도 쓰기는 차단됨

동시성을 위해 읽는락, 쓰기락을 나눠서 처리함

## 2단계 락킹
락을 사용하되 2단계 락킹 기법을 사용하지 않을경우 발생할수 있는 문제

TODO: 아니 가운데 의사 코드에서 왜 락이 저절로 풀어져?

솔루션: 트랜젝션이 끝날때 락을 품;;모  여러개 락을 가질순 있지만 이먼

TODO: 테이블 필요

## 데드락
쓰기쓰기 문제에서 생기는 문제

Os에서의 데드락이 그대로 나온거임

Todo: table example

누굴 하날 죽이는것밖에 답이 없음

누구 때문에 교착상태가 발생한지 모르기 대문에 둘중 하나가 죽음, 죽엇다는것은 롤백 됀다는 뜻임, 나머지 한쪼근 교착상태가 있는주 모르고계속 실행, 죽은애를 다시 실행해주는 기능은 없음

지금까지 한게 쓰기쓰기임

***

락이란건 기본적으로 동시성을 해치는 행위, 극단적으로 해석하면 동시성 생각 안하고 q에 놔서 선입선출 하면 됨

쓰기 읽기 시작

# dirty read(오손 읽기)
* T1: 읽기
* T2: 쓰기

실제 내부적으로 실행되는 예시

T2가 갑자기 무슨 일이 생겨서 롤백됏을때 예시, 이 예시는 30이 맞는 데이터고 21이 틀린 데이터, T2가 21로 수정하다 틀린 데이터라 롤백했지만 T1이 틀린데이터인 21을 읽어들인 상황

TODO: 예시 table 필요

근데 이런 생각 할수도 있음, 굳이 막아야 할까? 개발자가 상관 없으니 ㄱㅊ다! 할수도 있는데, 군사목적 같이 무조건 맞아야 한다면 어떨까?

## 반복불가능 읽기
내부적으로 T1은 읽고 T2는 업데이트 함 그리고 커밋 함, 그리고 T1이 다시 읽음, 이런 상황 가정

T1은 2번 읽는데 처음 읽는것과 두번째 읽은게 다름, 어떻게 보면 논리적으로 정상적인 상황일수도 있음

이또한 문제가 된다면 막아야 함

위는 ROLLBACK이 문제라면 이번엔 COMMIT 때문에 문제 발생

## 유령 데이터 읽기
T1은 읽고 T2가 INSERT 하는 상황, 이후 T1이 다시 읽을시 생기는 상황

처음 읽을때의 결과와 두번째읽을때 결과의 튜플의개수가 다름

유령같이생겨서 팬텀

위 가지는 저부 고립성이 깨진 상황

위 3가지는 절대적인게 아님, 허용 할수도 있음, 쓰기 쓰기 는 절대임!

***

# 막기 위한 방법
## 트랜잭션 고립 수준명령어
이전엔 시작과 끝만 선언했다면 이제 추가적인 명령어 써야함

TODO: 표 필요

근데 이론적으론 이런데 오라클은 2가ㅣ만 지원함, DB마다 다름

LEVEL READ UNCOMMITTEd 를 선언하면 돼야 하지만 오라클이 지원 안함

아무것도 안붙이면 처음 빨간거

***

어떻게 막았을까? 제일 어려운 예기

# Read UNCIMMITTED, LEVER = 0
읽기 할때 아무런 락을 안걸음

그 이후 쓰기가 락을걸고 수정을 하고 다시 읽기를 함

읽는게  아무런락 을 걸지 않았기에 T2가 맘대로 사용 가능

# READ COMMITTEd
읽기 할시 공유럭을 검 끝나면 바로 해지

첫번째 읽기시 락 걸고 푼다음 쓰기 다시 두번째 읽기 시 공유락을 다시 검,쓰기를 위한 T2는 베타락을 거는건 당연

이전표를보면 쓰기를 할시 누가 읽기락을 걸어놓고 있으면 대기하게 됨

OS의 스케줄링과 비슷함

T2가 롤벨해도 전혀 상관 없음

# 레벨 2
읽시 시 공유락 걸고 끝날때 까지 유지

위와 무슨 차이? 락을 최대한 안걸기 위한 노력임

# 시리얼라이즈
아주 강력

역시 읽기가 문제, 공유락을 걸고 트랜잭션 끝까지 유지, 이건 위와는 독같음

베타락 설정한ㄴ것도똑같음

인서트 문이라 발생하는 문제임

다른건

인덱스에 공유락을 검

좀 어려운 예기긴 한데..

일단 읽기 쓰기 읽기 할시 T1은 끝날때까지  LS 를 검

인서트하는 튜플은없는 객체기 때문에 Lx를 걸수가 없음

예전에 봤는데 각 튜플을 가리키는 인덱스 라는 개념을 말했음, 도한 PK는  자동으로 인덱스가 붙음

그리고 이러한 인덱스는 물리적인 파일로디스크에 저장되어 있음

여기ㅓ 예기 하고자 하는 예기는 새로운 튜플을 인서트할시 해당 테이블에만 인서트 하냐? 아님 인덱스에도 추가해야함

그래서 여기서 말하고자 하는건 이 인덱스에 공유락을 걸어버리는거임, 이렇게 하면 INSERT 는 INDEX를 건드려야하는데 인덱스 파일자체에락이 걸려있으니 대기가 발생, 언제까지?

T1이 커밋이 될때까지

인덱스가 뒤로 밀린다? 뭔 말이지

락킹 말고도 여러 방법이 고안돼었긴 했는데 살아남은건 락킹이 거의 유일하다 보면 됨

근데 락을 쓰면 데드락이 발생할 수 있음

***

# 실험

***

# 회복(recovery)
지금 예기하는 화복도 있는데 제일 마지막에 복원이란 파트가 있음, 이것도 회복이라 할수 있음, 잠시 예기해주면 디스크가 깨지는 경우를 예기함

지금 예기하는건 전원같은게 나가가지고 트랜젝션이 깨지는 경우를 예기함

즉 DB에 장애가 발생해도 일관성을 유지하는것이 recovery 임

트랜잭션은 기본적으로 All or Not 임

이때 중간에 오류가 생겨서 뒤로 돌아가려 할 상황이 발생하면뒤로 돌아가야 함,이때 로그파일을 씀

일단 DB 시스템에서 발생하 수 있는 장애 유형부터 알아보자

## 장애 유형
완벽히 나누어 지는건 아니고 이런걸 생각할 수 있음

* 시스템 충돌: HW, SW의 오류로 인해 RAM의 정보다 손실되어, RAM에 상주해 있던 프로그램과 데이터가 손실, 가장 흔한 상태임
* 미디어 장애: 이것도 일종의 HW의 장애일수도 있음
* 완벽한 SW란 있을순 없으니... os에도 에러가 발생할 수 있음
* 자연재해
* 부주의 혹은 태업: 사람이 실수로 컴퓨터 끌수도 있음

## 다이어그램

## 로그파일
트랜잭션이 반영한 모든 데이터의 **변경 사항**을 DB에 기록하기 변경하기 **전에** 미리 기록해두는 별도의 데이터 베이스, 읽는건 상관없음

기록한 후에 기록하지 않음, 그리고 이또한 DB임

근데 DB도 디스크에저장돼고 로그도 디스크에 저장돼는건 뭔가 이상함, 디스크 뽀개지면 끝이자나

로그파일은 별도의 저장장치, 보다 안전힌 디스크에 저장됨, 물론 실습으로 쓰는 개인 컴퓨터로 쓰면 같은 디스크에 저장돼고, 은행 같은곳에선 이렇게 함 사실 대부분 하나의 디스크로 처리하긴 함

### 로그의 구조
인서트라면 어떤 테이블에 어떤 튜플이 추가돼었단 정보가 있겠지

## 로그 파일을 이용한 회복
UPDATE 는 사실 read 와 write의 조합이기 때문에 엄밀힌 틀렸지만 편의상 이렇게 보겠다.

TODO: 67page

핵심은 read 될때가 아닌 wriet 돼기 전 로그에 적힌다는 거다.


TODO: 69page

이때 특정 로그번호에서 죽었다 가정 하자 이때 T2 중간에 꺼졌다면 10번의 COMMIT 기록은 없을거다. COMMIT이 적혀있어도 사실 COMMIT이 돼있다고 할수도 없다.

이제 다시 컴퓨터를 켜서 ㄱ동되면 DBMS는 로그파일을 먼저 살펴본다....

이때 트랜잭션을 복구하는 방법은 2가지다,

### REDO
이전에 COMMIT이 돼 있어도 또 적는다. COMMIT이 돼 있다면 뒤에있는 값(여기선 10이 더해진 값)으로 다시 적는다. 확인사살을 한다 생각해도 괜찮다.

### UNDO
COMMIT이 없는 경우다. 이때는  NOTHING로 만들어야 한다. 위 예제에선 7번까지 적혀있는 경우다. 이땐 REDO가 불가능하니 NOTHING로 만들어 버린다. 이때 방법은 OLD값으로 써주면 돼니 쉽다.


## 커밋의 타이밍

이전에 커밋을 해도 disk에 안써질수 있다 했다. 성능 이슈 때문에.. 근데 이때 커밋을 언제 할지에 따라서 로그를 쓰는 방법도 달라진다.

이를 구분해 즉시 갱신 방법과 지연 갱신 방법 두가지로 나뉜다.

근데 이때 디스크에 저장 한다음  COMMIT 하는 방법을 사용한다 해도 사실 disk에 넣는건 OS의 역할인데.. 이 OS도 디스크에 바로 작성하는게 아니라 이 경우에도 COMMIT 시 반드시 disk에 있다 생각할순 없다. 참.. 뭣같네