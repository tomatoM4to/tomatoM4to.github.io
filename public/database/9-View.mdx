# View
하나 이상의 테이블을 합하여만든 가상의테이블

진짜 ㅔ이블은 CREATE로 만든거

```sql
CREATE VIEW vorders...
```
이런식식으로 테이블 만드는것것처럼 만들수 있다

View 에서도 진자 테이블처럼 SELECT 가능하다.

보안성: 고객의 전화번호를 보여주기 싫고 뷰 내부의 데이터만 뽑뽑보여주는 식

편리성: 진짜 테이블을 만들면 데이터 중중복이 생기고 나중에 무결성 문제가 생길 가능능성이 매우 커짐

3단계 데이터베이스 구조

Book, Customer.. 등등등을 스키마 라고 하고, 이를 개념 스키마 라고 함

그리고 View를통해 진짜 사용자에게 보여주는 데이터를 외부스키마 라 한다.

그리고 이러한 스키마를 하드?에 저장하는데 이를 내부 스키마 라고 한다.

논리적 데이터 독립성: 나중에 배운다.

## 특징
1. 그냥 가상으로 연결결됀것 뿐이기 때문에 update를 통한 무결성 문제가 없음
2. 진짜테이블은 아니라 인덱스 생성이 어려움
3. CRUD가 일반적으로 안안됌, 억지로는 돼는데 기기본적으론 XX, 됀다면 사실 그게 더 이상함
4. 삭제도 자유로움



## 수정
별로 많이 쓰진 않는데..

```sql
CREATE OR REPLACE VIEW vw...
```
없으면 만들고 있있으면 수정하고

***

# 인덱스
좀 어려운 개념이기도 하고 매우 중요하지만, SQL 관점에서만 보겠다.

# 데이터베이스의 물리적 저장
Data Base는 결국 HDD, SSD에 DB Files들들이 저장이 됀다.

이러한 파일에는 3가지가 있는데 나중에 배운다. 

테입ㄹ에대한 파일을 찾고싶으면 데ㅣ터파일을 찾으면 됀다. xxx.dbf? 이러한 하나 또는 두개의 파일들에 테이이블, 인덱덱스가 들어있다. 하지만 내부 구조를 확인할순 없없다.

오라클 INsTANCE는 메인메모리에 들어가게 됀다. 여기 부분에선 HDD, SDD 내부가 더 중요하기에 필요 없다.


1. INSTANCE: RAM에 있음, 오라클을 실행하면 수많은 프로세스가 돌아가게 됀다. 정말 무거운 프로그램이다~, 실제로 수많은 사람이 공동으로 사용하기 때문에
2. DATABASE: 보조 저장 장치에 있음


근데 이때, HDD.. 아직까진 많이 쓰니까 이때 ram과 MEMORY에 엑세스 속도는 1만배정도차이가 나게 돼서

이걸 좀좀더 빠르게 찾기 위해 도입된게 인데스(자료구조?) 시스템이다.


Buffer Cache: 실제로 보조저장 장치에서 데이터를 읽을때 블럭단위ㅗ 읽기 때문에 캐싱할수 있다.




예를들어, 어떤 단원을 찾기 위해 목차에서 페이지를 찾아 가는것과 비슷하다. 이게 인덱스의 개념이다.

테이블에는 튜플들이 있는데 이걸 하나씩 읽진 못한다. 섹터터를 한번번에 읽는데, 이때 특정 튜플을 읽읽는데 이때 만약 튜플이 마지막에 있다면 매우 시간적 낭비가 됀다?

인덱스는 결국 테이블과 똑같이 표라 생각해도 됀다.

특정 튜플을 찾고자 할때

Users table
|id|name|age|
| 1| qq | qq|


|키||포인터|
|--|---|
|1 | 34|

이게 키값을 기준으로 정렬이 돼있다.

근데 문제가 있다면 튜플은 수시로 바뀌는데 id가 수정이돼면 정렬이 수행돼는데 이 오버헤드가 매우 높다. 그래서 일반적인 표로 만들진 않고 B-Tree 형태로 구현이 됀다. B-Tree는 검색과 변화에 대한 효율성이 매우 높다.

근데 이러한 B-Tree는 어디에 있을까? 프로그램상엔 없고 HDD, SDD에 파일 형태로 저장돼어 있다. 보통 Data 파일에 테이이블과 함께 저장돼어 있다? 보통 Data파일에 테이블과함께 저장돼어 있다 부분이 애매함



그래서 일반적인 테이블에도 인덱스가 하나씩 붙여있다. pointer 처럼 하하드 어느 위치에 있는지에 대한 pointer가 있다. 이러한 인덱스도 실제로저장이 돼는 데이터옆에 하나씩 붙여진체 하드에 저장됀다.

그러므로 데이터 파일: 데이터 + 인덱스

하드에 액세스 하기 위한 시식을 줄이기 위해 바로바로 찾기 위해 이러한게 도입돼어 있다.

이러한 인덱스를 효율적으로 관리하기 위해 B-tree라는게도입돼어 있다, 단순히 2차원 테이블로만들어 버리리는거에 비해 시간복복잡도를 줄일수 있다.

하드드에는 데데이터를 섹터 단위로 저장하는데, 이를 block라 말하기도한다.

온라인 리두 로그, 컨트롤파일은 뒤에에서 하게 됀다.


## 특징
1. 보통 하하나의 속성을 이용하여 생성한다.
2. key와 포인터만 있으면 됀다.


## 생성
이것도 결국 SQL러 생성하게 됀다. 이거 말고도 여러 인덱스가 있는데, 대학원 수준이라 넘어간다.

이것마 알면 돼긴 하는데, CREAETE 해서 눈에 보이지 않음, 확인이 돼지 않음

겉으론 보이진 않아아도 속으론 개선이 됀다.

이러한 인덱스를 제대로 붙일라면 공부를 많이 해야 한다.

보통 select와 join에 많이 사용돼는 테이브에 붙붙이다

근데 이러한 인덱스도 보통 8개? 이상 만들진 않는다. 오버헤드가 커서...

참고로 테이블 내 primiry key에는 인덱스가 자동으로 붙게 됀다.

다른른테이블에 JOIN을 많이 사용돼는 특정 속성이 있다면 이부분에 인덱스를 넣는ㄷ면 개선이 됀다는 뜻이다.

하지만 테이이블당 인덱스 많아봐야 4 ~ 5개 정도, 검색은 빠른데 업데이트가 많이 느려짐

당연하지만 백만개의 튜플중 5개, 10개 정도도의 튜플을 검색하는 선택도가 낮을때 인덱스를 붙이는게 유리하다.

gui를 보면

인덱스 최적화는 DBA의 역할이이다.
1. table이 있고
2. view
3. 인덱스
    * 내가 어떤 인덱스를 만들었냐 볼수 있다

## 비 클러스터 인덱스
테이블이 만들어진다면 (book_id, name) book_id 인덱스가 많들어진다. 근데 이때 book_id가 완전히 정렬돼어 있다면 굳이 B-Tree를 쓸까 클러스터드 인덱스. 비 클러스터 인덱스는 그저 정렬돼어있는 속성에 인덱스가 있냐 없냐다. 보통 book_id 같은 속성에는 클러스터드인덱스가 붙는다?

```sql
SElect
```
price에 인덱스를 붙이면 전체에 대해 price를 검색하는게 아닌 인덱스를 이용해 찾아 훨씬 빨라진다.



```sql
ALTER INDEX name REBUILD
```
수정, 삭제, 추가가 반복돼면 중간에 빈자리가 많이 생기기 때문에 이 인덱스를 압축축해 컴팩트하게 만ㄷㄹ라는 의미로 REBUILD 옵션을 쓸수 있다.
***

