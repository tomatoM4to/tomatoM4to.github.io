# 데이터 모델링을 하는 이유

현실을 컴퓨터가 이해할 수 있는 형태로 변환하는 작업을 데이터 모델링이라고 합니다.

이러한 추상적인 일은 매우 어렵고 정답도 없는 일이다 보니, 사람들은 일정한 규칙을 정해놓고 그에 따라 데이터 모델링을 진행합니다.

그 규칙을 배운다 생각하면 됩니다.

이러한 데이터 모델링에는 보통 아래의 과정을 거쳐 진행됩니다.

1. 업무 파악 → 말 그대로 팀원들이 회의를 통해 어떤걸 모델링 해야 하는지 파악하는 일입니다.
2. 개념적 데이터 모델링 → 업무 파악을 통해 어떤 데이터를 모델링 해야 하는지 파악했다면, 그 데이터를 추상화하여 개념적 데이터 모델링을 진행합니다. 이 단계에서는 데이터의 속성이나 관계를 정의합니다.
3. 논리적 데이터 모델링 → 개념적 데이터 모델링을 통해 정의한 속성과 관계를 바탕으로, 실제 데이터베이스에서 어떻게 구현할지를 고민하는 단계입니다. 이 단계에서는 테이블, 컬럼, 키 등을 정의합니다.
4. 물리적 데이터 모델링 → 논리적 데이터 모델링을 바탕으로 실제 데이터베이스에 구현하는 단계입니다. 이 단계에서는 데이터베이스의 구조, 인덱스, 파티션 등을 정의합니다.

데이터베이스 는 한번 만들어 놓으면 수정을 쉽게 할 수 없기 때문에, 데이터 모델링을 통해 미리 충분히 고민하고 설계하는 것이 중요합니다.

어렵게 풀어쓰긴 했지만 사실 `설계 → SQL 작성 → db에 반영` 인것 뿐입니다.

이번 장에선 **업무 파악** 은 다루지 않겠습니다.

***

# 개념적 데이터 모델링

# 논리적 데이터 모델링

먼저 논리적 데이터 모델링을 하기 전에, 어떤 프로그램을 사용할지 정해야 합니다.

정하는 이유는 여러가지 있지만, 논리적 데이터 모델링을 통해 SQL 을 자동적으로 생성할 수 있기 때문입니다.

이전에 Table 을 만들때 순서를 신경써야 했었는데, 해당 프로그램들은 이것들을 자동으로 처리해줍니다.

| 기호 | 개념적 의미 | 논리적 의미 |
| ---- | ------------ | ------------ |
| ○    | Entity       | Table        |
| □    | Attribute    | Column       |
| ◇   | Relation     | PK, FK       |

만들 때 명확한 순서는 없지만, 키가 가장 적은 엔터티부터 모델링하는 것이 가장 쉽습니다.

화살표들도 알기 쉬움, 아래 4개만 알면 됨

![erd-arrow](./public/kr/database/img/erd-arrow.png)


1:1 과 1:N 관계는 매우 쉬움

## 1:1
먼저 이러한 1:1 관계는 거의 없고, 가능한 한 테이블로 나누지 않는게 좋아요.

하지만 예시로 하나 들자면 Account 와 DormantAccount 를 예로 들 수 있습니다.

Account 테이블은 활성화된 계정에 대한 정보를 담고 있고, DormantAccount 테이블은 휴면 계정에 대한 정보를 담고 있습니다.

이러한 구조의 Account는 DormantAccount를 필수로 가지지 않아도 되지만, DormantAccount는 반드시 하나의 Account를 가져야 합니다.

그러므로 위 사진의 2번째 화살표인 선택적 1:1 관계를 사용하여 표현할 수 있습니다.


## 1:N

가장 많이 사용되고 일반적인 관계 입니다.

이번엔 게시판을 예로 들어보겠습니다.

* 한 유저는 여러 게시글을 작성할 수 있습니다.
* 한 게시글은 하나의 유저에 의해 작성됩니다.
* 유저는 게시글을 작성하지 않아도 됩니다.

이러한 3가지 조건을 만족하는 선택적 1:N 관계인 4번째 화살표를 사용하여 표현할 수 있습니다.

그리고


* 유저는 여러개의 댓글을 작성할 수 있습니다.
* 댓글은 하나의 유저에 의해 작성됩니다.
* 유저는 댓글을 작성하지 않아도 됩니다.
* 게시글은 여러 댓글을 가질 수 있습니다.
* 댓글은 하나의 게시글에 속합니다.
* 게시글은 댓글을 가지지 않아도 됩니다.


댓글의 이러한 속성은 User 와 1:N 관계를 가지며, Post 와도 1:N 관계를 가집니다. 물론 둘다 선택적 관계입니다.

***

# N:M

가장 복잡한 관계입니다. 그리고 이해하기 힘들 수 있습니다.

사실 위에서 말한 1:N 관계를 통해 N:M 관계를 표현할 수 있습니다. 위에서 말한 댓글 또한 사실상 User 와 Post 의 N:M 관계를 표현한 것입니다.

* 유저는 여러개의 댓글을 작성할 수 있습니다.
* 게시글은 여러 댓글을 가질 수 있습니다.

일단 반대로 생각해 봅시다. 위 두 조건을 만족시키며 User 와 Post 이 두개의 테이블만 가지고 N:M 관계를 표현할 수 있을까요?

일단 정답부터 말하자면 관계 데이터 모델에선 불가능합니다.

이게 무슨 말이냐면, 아래와 같이 표현하면 어떻게 되긴 합니다.

* post_id 는 어떤 게시글에 대한 댓글인지 나타내는 컬럼입니다.
* comment 는 해당 게시글에 대한 댓글 내용 입니다.

| email | password | post_id | comment |
| ------ | -------- | ------ | ------- |
| `a@a.com` | 1234     | 1   | a 입니다. |
| `a@a.com` | 1234     | 1   | 두번 째 뵙네요 |
| `b@b.com` | 1234     | 2   | b 입니다. |

혹은 다른 방법으로 한 Column 에 여러개의 값을 넣는 방법도 있습니다.

이렇게 관계 데이터 모델을 따르지 않는다면 N:M 관계를 표현할 수 있습니다.

하지만 일반적인 관계형 데이터 모델을 따른다면, 이야기가 달라집니다.

보통 `email` 은 **UNIQUE** 제약조건이 걸려있기 때문에, 위와 같은 방법은 불가능합니다. 혹은 `email` 이 **UNIQUE** 해야 하지만 댓글을 위해 억지로 제약을 풀 수 도 있고요.

그렇기에 관계 데이터 모델 조건을 따르면서 N:M 관계를 표현하기 위해선 **Mapping Table** 을 사용해야 합니다.

위에서 말한 Comment 테이블이 바로 Mapping Table입니다. 추가적으래 `comment` 라는 추가 속성을 가지고 있어 완전한 Mapping Table 이라고 할 순 없지만 기능적으론 Mapping Table 의 역할을 하고 있습니다.

Mapping Table 은 두 개 이상의 테이블 간의 N:M 관계를 표현하기 위해 사용되는 테이블입니다. 이 테이블은 두 개의 외래 키(Foreign Key)를 포함하여, 각 외래 키는 다른 테이블의 기본 키(Primary Key)를 참조합니다.

| user_id | post_id | comment |
| -------- | ------- | ------- |
| 1        | 1       | a 입니다. |
| 1        | 1       | 두번 째 뵙네요 |
| 2        | 2       | b 입니다. |

이렇게 새로운 테이블을 만들어서 User 와 Post 의 N:M 관계를 표현할 수 있습니다.

이러한 구조는 학생 과 수업 관계를 표현할 때도 사용됩니다.

학생은 여러 수업을 들을 수 있고, 수업은 여러 학생이 들을 수 있습니다. 이 경우에도 한번 두 테이블만 가지고 표현할 수 없습니다.

그렇기에 학생과 수업 테이블 중간에 수강 테이블을 만들어서 학생과 수업의 N:M 관계를 표현해야 합니다.

난해한 관계지만, 매우 중요하므로 천천히 이해해보세요.