> [https://www.youtube.com/watch?v=N_qURj2Wtn8&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM&index=39](https://www.youtube.com/watch?v=N_qURj2Wtn8&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM&index=39)

# Http 의 4가지 특성

## 요청-응답 기반 프로토콜
- 서버 클라이언트 모델
- Request 가 주어지면 서버는 Response 를 반환, 이 두 메시지는 서로 다른 형태를 가짐

## 미디어 독립적 프로토콜
- HTTP 는 텍스트, 이미지, 비디오 등 다양한 형태의 데이터를 전송할 수 있음
- HTTP 는 그저 데이터 전송을 위한 Interface 역할을 함
- HTML, WEBP, PNG, JSON, PDF 등등
- 파일을 식별하기 위해 확장자를 사용하든 HTTP 에선 **Media Type** 를 이용하여 메세지 가 어떤 형식인지 알려줌
- 예를 들어, `Content-Type: text/html` 이라고 하면 HTML 문서
- 타입은 `type/subtype` 형태로 표현됨
- 예시: `text/html`, `image/webp`, `application/json`
- `*` 와 같은 와일드카드를 사용하여 모든 타입을 지정할 수도 있음
- 예시: `image/*`, `application/*`

**자주 사용되는 미디어 타입 정리**
| 타입 | 타입 설명 | 서브타입 | 서브타입 설명 |
|------|-----------|----------|----------------|


## 상태를 유지하지 않는 프로토콜

일반적으로 HTTP 는 한 서버가 많은 클라이언트의 요청을 처리할 수 있도록 설계됨, 만약 서버가 모든 클라이언트의 상태를 기억한다면 서버의 부하가 증가하고 확장성이 떨어짐

추가적으로 현대의 웹 애플리케이션은 종종 여러 서버에 걸쳐 분산되어 있기 때문에, 각 서버가 클라이언트의 상태를 기억하는 것은 복잡도가 증가하게 되고 중복되는 상태 정보를 저장하는 등 비효율적인 구조가 될 수 있음

결국 Stateless 한 특성은 Client 가 얼마든지 확장되어도 서버는 문제없이 처리할 수 있도록 해줌

- Stateless Protocol 이라 불림
- Server 가 HTTP 요청을 보낸 Client 와 관련된 상태를 기억하지 않는다는 의미
- Client 의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주
- 그렇기 때문에, 로그인 세션, 장바구니 등과 같은 상태 정보를 유지하려면 별도의 메커니즘이 필요

하지만 이러한 방식은 확장성(scalability) 엔 도움이 되지만 같은 요청을 다시 보내야 하는 경우(예: 페이지 새로고침) 단점이 될 수 있음

이러한 단점을 해결하기 위해 Cookie, Cache, WebStorage 와 같은 방식과 함께 사용됨, 이후 알아볼 예정


## 지속 연결을 지원하는 프로토콜

**Persistent Connection** OR **Keep-Alive Connection** 라고도 불림

결론부터 말하면 하나의 TCP 연결상에서 여러 개의 Request-Response 쌍을 처리할 수 있는 기술을 의미함

**비지속 연결의 특징**
- HTTP 1.0 이하 버전에서 사용됨
- TCP 연결 수립 후, 요청에 대한 응답을 받으면 연결 종료
- 추가적인 Request-Response 쌍을 처리하기 위해선 다시 TCP 연결 수립부터 반복

**지속 연결의 특징**
- HTTP 1.1 이상에서 기본적으로 지원됨
- 하나의 TCP 연결을 통해 여러 개의 Request-Response 쌍을 처리

***

# HTTP 메시지 구조

기본적으로 HTTP 1.1 버전을 기준으로 개념적으로 설명할 예정, 이후 실제로 어떻게 생겼는지 알아볼 예정

* 가장 많이 사용되는 HTTP 버전
* 평문 형태의 메시지라 읽기가 쉽고, 디버깅이 용이함

기본적으로 HTTP 메시지는 크게 두 부분으로 나뉨
1. Start Line
    - Start Line 은 메시지의 첫 번째 줄로, 요청(Request) 또는 응답(Response)의 종류와 관련된 정보를 포함
    - Request 의 경우 `GET /index.html HTTP/1.1` 와 같은 형태로, 요청의 종류와 대상, HTTP 버전을 포함
    - Response 의 경우 `HTTP/1.1 200 OK` or `HTTP/1.1 404 Not Found` 와 같은 형태로, HTTP 버전과 상태 코드, 상태 메시지를 포함
2. Header Line
    - HTTP 통신을 하기 위해 필요한 부가 정보를 포함
    - 0개 일 수도 있음, 하지만 실제론 굉장히 많은 header 가 포함되어 있음
    - `:` 기준으로 header-name 과 하나 이상의 header-value 로 구성
    - 예시: `Content-Type: text/html`, `User-Agent: Mozilla/5.0`
2. Body
    - 실제 데이터가 포함되는 부분
    - Request의 경우, 서버에 전송할 데이터가 포함되고, Response의 경우, 서버가 클라이언트에 전송할 데이터가 포함됨
    - 선택적 부분으로, 필요하지 않은 경우 비워둘 수 있음
    - 예시: HTML 문서, JSON 데이터, 이미지 파일 등

이전에 Http 는 데이터 종류에 상관없이 전송할 수 있는 플로토콜 이기에 Body 엔 다양한 형태의 데이터가 포함될 수 있음, 그러기에 학습하는 입장에선 Header Line 의 구조를 이해하는것이 중요함


## CURL 로 HTTP 메시지 구조 확인하기

Http 구조를 확인하기 위한 아주 좋은 도구와 서비스가 있음

`curl` 명령어는 HTTP 요청을 보내고 응답을 받을 수 있는 커맨드라인 도구로, HTTP 메시지의 구조를 확인하는 데 유용함

그리고 `httpbin.org` 는 HTTP 요청을 테스트할 수 있는 서비스로, 다양한 HTTP 요청을 보내고 그 결과를 확인할 수 있음

```bash
curl -v https://httpbin.org/get
```

`-v` 옵션은 verbose 모드로, 요청과 응답의 상세 정보를 출력함

결과적으로 아래의 Request 메시지를 확인할 수 있음, 해당 메시지를 `httpbin.org` 서버에 GET 요청을 보낸거임

```http:Request
GET /get HTTP/2
Host: httpbin.org
User-Agent: curl/8.5.0
Accept: */*

```

빈줄 뒤에 아무것도 없는것을 보니 Body 가 없는 Request 메시지임, 각각의 줄은 다음과 같은 의미를 가짐

1. Start Line
   - `GET /get HTTP/2` : GET 메서드를 사용하여 `/get` 리소스를 요청하며, HTTP 버전은 2임
2. Header Line
    - `Host: httpbin.org` : 요청을 보낼 호스트 이름
    - `User-Agent: curl/8.5.0` : 요청을 보낸 클라이언트의 정보
    - `Accept: */*` : 클라이언트가 어떤 타입의 응답을 받을 수 있는지 지정, 여기서는 모든 타입을 허용함

그에 대한 Response 메시지 또한 확인할 수 있음

```http:Response
HTTP/2 200
date: Tue, 24 Jun 2025 11:32:16 GMT
content-type: application/json
content-length: 253
server: gunicorn/19.9.0
access-control-allow-origin: *
access-control-allow-credentials: true

{
  "args": {},
  "headers": {
    "Accept": "*/*",
    "Host": "httpbin.org",
    "User-Agent": "curl/8.5.0",
    "X-Amzn-Trace-Id": "Root=1-685a8cc0-0a2a718351292ebf71b68461"
  },
  "origin": "your_ip_address",
  "url": "https://httpbin.org/get"
}
```

1. Start Line
   - `HTTP/2 200` : HTTP 버전과 상태 코드
2. Header Line
    - `date: Tue, 24 Jun 2025 11:32:16 GMT` : 요청이 처리된 날짜와 시간
    - `content-type: application/json` : 응답의 콘텐츠 타입
    - `content-length: 253` : 응답 본문의 길이
    - `server: gunicorn/19.9.0` : 서버 정보
    - `access-control-allow-origin: *` : CORS 정책
    - `access-control-allow-credentials: true` : CORS 정책
3. Body
    - JSON 형태로 body 를 받았음

***

# Http 메서드

Http 메서드의 종류는 많지만 가장 많이 사용되는 몇가지를 정리해볼 예정

먼저 알아둬야 할것은, Http 메서드는 일종의 약속으로서 필요하다면 직접 정의할 수도 있음

하지만 일반적으로 Client 와 Server 간의 통신에선 Client 의 브라우저가 표준에 맞지 않는 메서드를 거부할 수도 있기에, 표준에 정의된 메서드를 사용하는 것이 좋음

하지만 많은 경우 1번 API 는 GET, 2번 API 는 POST, 3번 API 는 PUT 등과 같이 메서드들을 완전히 구분짓는건 매우 어려움

많은 부분이 개발자가 어떻게 설계하는지에 달려있음

## GET

- 서버로부터 데이터를 요청할 때 사용됨
- 일반적으로 Body 없이 요청을 보냄
- Body 를 사용하지 않는 대신 URL에 쿼리 파라미터를 포함하여 데이터를 전달 하는것이 일반적
- 예시: `GET /users?id=123 HTTP/1.1`

GET 메서드는 주로 데이터를 조회할 때 사용되며, 서버에 데이터를 요청하는 가장 일반적인 방법

Body 없이 요청을 보내는것이 표준에 정의되어 있음

> A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.
>
> [https://www.rfc-editor.org/rfc/rfc7231#section-4.3.1](https://www.rfc-editor.org/rfc/rfc7231#section-4.3.1)

## POST
- Sign in, Sign up, 데이터 생성, 결제 등 Client 가 Server 에게 데이터를 전송할 때 사용됨
- 데이터는 Body에 포함되어 전송됨

가장 범용적으로 사용되는 Http 메서드로, GET, PUT, DELETE 등 다양한 작업을 하는데 문제 없이 사용할 수 있음

하지만 Http 표준에선 POST 는 데이터를 생성하기 위한 메서드로 정의되어 있음

> POST serves many useful purposes in HTTP, including the general purpose of “this action isn't worth standardizing.”

만약 게시글 만들기 기능을 구현한다고 가정해보자, 이때 사용자가 입력한 데이터를 서버에 전송하기 위해 POST 메서드를 사용함

이때 요청 메시지는 다음과 같은 형태가 될 것임

```http
POST /users HTTP/1.1
Content-Type: application/json

{
    "id": 123,
    "title": "Hello World",
    "content": "This is my first post!"
}
```

만약 서버에서 처리가 정상적으로 완료가 된다면 Server 는 Client 에게 해당 포스팅이 생성된 위치와 201 Created 상태 코드를 반환할 것임

Location 이나 Body 에 데이터를 포함할것은 선택사항, 지금은 예시를 위해 포함함

```http
HTTP/1.1 201 Created
Location: /users/123
Content-Type: application/json

{
    "id": 123,
    "title": "Hello World",
    "content": "This is my first post!"
}
```

## HEAD
- GET과 유사하지만, 응답 Body 을 포함하지 않음
- 주로 응답 헤더만 확인하고 싶을 때 사용됨

## PUT
- 서버에 있는 리소스를 업데이트할 때 사용됨
- POST 처럼 Body 에 데이터를 포함하여 전송하는것이 일반적
- PUT 메서드는 주로 리소스의 전체를 업데이트할 때 사용됨

## PATCH
- PUT과 유사하지만, 리소스의 일부를 업데이트할 때 사용됨
- 예를 들어, 게시글의 제목만 변경하고 싶을 때 사용

## DELETE
- 서버에 있는 리소스를 삭제할 때 사용됨


***

# Http 상태 코드

Http 메서드는 Client 가 Server 에게 요청을 보낼 때 사용되는 방법이라면, Http 상태 코드는 Server 가 Client 의 요청에 대한 응답을 나타내는 코드임

* 100번대 : 정보성 상태 코드
* 200번대 : 성공 상태 코드
* 300번대 : 리다이렉션 상태 코드
* 400번대 : 클라이언트 오류 상태 코드
* 500번대 : 서버 오류 상태 코드

100번대는 거의 사용하지 않음, 이또한 완전히 구분되는 경우보다 모호한 경우가 많기에 개발자가 어떻게 설계하는지에 달려있음

다른 상태 코드는 명확하다 300번대가 살짝 모호할 수 있으니 따로 설명하겠음

## Redirect 상태 코드

먼저 공식문서에서 말하는 Redirect 상태 코드의 정의를 살펴보자

> The 3xx (Redirection) class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request. There are several types of redirects
>
> [https://www.rfc-editor.org/rfc/rfc9110#name-redirection-3xx](https://www.rfc-editor.org/rfc/rfc9110#name-redirection-3xx)

상황으로 설명하는것이 가장 이해하기가 쉬운데, 이런 상황을 가정 할 수 있음

> 1. 사용자가 A 페이지를 요청했는데, 해당 페이지가 B 페이지로 이동되었음
> 2. 이때 서버는 `301 Moved Permanently` 상태 코드를 반환하고, `Location` 헤더에 B 페이지의 URL을 포함하여 클라이언트에게 알려줌
> 3. Client 는 이 정보를 바탕으로 자동으로 B 페이지를 새로 요청하게 됨 (브라우저의 경우 자동 처리됨)

이를 HTTP 메시지 흐름으로 표현하면 다음과 같음

```
1. 클라이언트 → 서버
GET /A HTTP/1.1
Host: example.com

2. 서버 → 클라이언트
HTTP/1.1 301 Moved Permanently
Location: /B

3. 클라이언트 → 서버
GET /B HTTP/1.1
Host: example.com

4. 서버 → 클라이언트
HTTP/1.1 200 OK
Body: (B 페이지의 실제 콘텐츠)
```

이렇듯 Client 즉 브라우저는 300번대 상태 코드를 받으면 헤더에 `Location` 이라는 필드를 확인하고, 해당 URL로 자동으로 요청을 보내게 됨

## 영구적인 Redirect

하지만 300번대 코드별로 브라우저가 자동으로 요청을 보내는 방식이 다름

먼저 영구적인 리다이렉션에 해당하는 상태 코드는 다음과 같음
- 301 Moved Permanently
- 308 Permanent Redirect

결론부터 말하자면 308 코드를 쓰는것이 좋음

RFC 9110 에서 말하는 301 에 대한 설명중 다음과 같은 설명이 포함됨

> For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 308 (Permanent Redirect) status code can be used instead.

일단 이러한 설명이 생긴 이유는 다음과 같음

```
1. 클라이언트 → 서버
POST /A HTTP/1.1
Host: example.com

2. 서버 → 클라이언트
HTTP/1.1 301 Moved Permanently
Location: /B
```

위 예시와 다른점은 첫번째의 `클라이언트 → 서버` 의 Method 가 `POST` 라는 점임

이제 이때 3번째의 `클라이언트 → 서버` 는 어떤 Method 를 사용해야 할까? 직관적으로 `GET` 을 사용해야 할 것 같지만 실제론 `GET` 과 `POST` 둘다 사용될 수 있다라는 의미

이렇게 불확실함을 줄이기 위해선 `308 Permanent Redirect` 상태 코드를 사용하는 것이 좋음, 만약 `308` 상태 코드를 사용한다면, 클라이언트는 원래의 요청 메서드인 `POST` 를 그대로 유지하여 `/B` 페이지로 요청을 보낼 것임

첫번째 요청이 `GET` 이라면 둘다 사용해도 무방함

추가적인 예기로, 영구적인 Redirect 는 주로 URL 변경이나 리소스 이동 시 사용됨, 예를 들어, 웹사이트의 구조가 변경되어 특정 페이지가 다른 URL로 이동한 경우에 사용됨, 이러한 경우 크롤러나 검색엔진에 큰 영향을 끼칠 수 있음

## 임시적인 Redirect

영구적이라면 일시적인 Redirect 도 있다는 뜻, 관련된 예기는 위와 비슷하니 간단히 표로 정리하겠음

| 상태 코드 | 설명 |
| ---------- | ---- |
| 302 Found | 재요청 Method 변경 가능 |
| 303 See Other | 재요청 Method GET 으로 번경 |
| 307 Temporary Redirect | 재요청 Method 변경 하지 않음 |



