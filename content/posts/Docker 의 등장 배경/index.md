---
title: "Docker 의 등장 배경"
description: "가상화 기술의 기초부터 Virtual Machine과 Container의 차이점을 비교하고, 이를 통해 Docker가 등장하게 된 배경과 핵심 개념을 정리합니다."
date: "2025-05-25"
keywords: "Docker"
---

# 가상화

Docker 를 이해하기에 앞서, 먼저 **가상화 기술**에 대해 간단히 짚고 넘어가야 합니다.

우선 컴퓨터가 무엇으로 구성되어 있는지부터 생각해 봅시다. 컴퓨터는 CPU, RAM, SSD(HDD)와 같은 **물리적 하드웨어**와, 이를 제어하는 **소프트웨어**로 이루어져 있습니다. 이 소프트웨어는 다시 **OS** 와 **Application** 으로 구분할 수 있습니다.

Application 은 하나 이상의 Process 로 구성되며, 이 프로세스들은 운영체제가 관리합니다. **각 Process 는 독립된 실행 환경**을 가지며, 서로의 메모리나 자원에 직접 접근하지 못합니다. 예를 들어, 우리가 VS Code를 실행하고 있다고 할 때, 해당 프로그램의 연산 결과가 동시에 실행 중인 Chrome 브라우저에 영향을 주어서는 안 됩니다. 이런 격리(독립성)를 운영체제가 보장하는 것이죠.

여기까지 이해했다면, 가상화의 개념을 받아들이는 데 충분한 배경지식을 갖춘 셈입니다.

## Virtual Machine

본격적으로 가상화에 대해 이야기해 보겠습니다.

VMware 와 같은 가상화 소프트웨어는 **Windows 같은 Host OS 위에서 Linux 같은 다른 OS 를 동시에 실행**할 수 있게 해줍니다. 이렇게 설치된 Linux 시스템을 Guest OS 라고 부릅니다.

이때 중요한 점은, **가상 머신 상의 하드웨어까지도 소프트웨어적으로 흉내 낸다는 것**입니다. 즉, CPU, RAM, 저장장치 등도 가상의 장치로 구현되어 Guest OS 에 제공됩니다.

TODO: 아래 그림(예시)을 상상해 보세요. Windows 호스트 위에서 두 개의 Guest OS 가 각각 하나의 애플리케이션(Process)을 실행하고 있는 상황입니다.

아래 그림은 Windows 에서 두개의 Linux 를 구동하고 각 Linux 에는 하나의 Process 가 실행되고 있는 상황인걸 볼 수 있습니다.

이 구성에서 실행 중인 주요 컴포넌트를 정리해보면 다음과 같습니다.

1. **Host OS** : 자체 커널, 자체 프로세스
2. **Guest OS 1** : 커널, 가상 하드웨어, 프로세스
3. **Guest OS 2** : 커널, 가상 하드웨어, 프로세스


단순히 개수만 세어도 총 8개 이상의 프로그램이 돌아가고 있는 셈입니다. 그런데 이 무거운 구조가 도입된 이유는 무엇일까요? 바로 Linux 환경에서 특정 프로세스를 실행하고 싶기 때문입니다. 다시 말해, **Process 2와 3을 Windows 환경과 분리하여 실행하기 위해, 각각의 Linux 커널과 가상 하드웨어를 별도로 실행하고 있는 것**입니다.

하지만 이렇게 무거운 커널과 하드웨어 전체를 매번 띄우는 구조는 굉장히 비효율적입니다. 단지 **Application 두 개를 실행하기 위해 전체 OS 와 하드웨어를 중복해서 사용하는 구조**는, 리소스 낭비가 명백하죠.

이러한 비효율을 극복하기 위한 기술이 바로 Container 입니다.

## Container

컨테이너 기술은 **굳이 전체 OS를 가상화하지 않아도 된다** 는 아이디어에서 출발했습니다. 핵심은 애플리케이션 **실행에 필요한 최소한의 환경만을 추상화해서 독립된 실행 공간**을 제공하는 것입니다. 이 독립된 실행 공간을 **Container** 라고 부릅니다.

그렇다고 해서 각 컨테이너가 운영체제의 기능을 전혀 사용하지 않는 것은 아닙니다. **여러 개의 Container 가 존재하더라도, 모두 하나의 OS Kernel 을 공유**하고 있으며, Docker Runtime 이 이들 간의 인터페이스 역할을 수행합니다. Container 가 하드웨어 자원(CPU, 메모리, 디스크 등)에 접근할 필요가 생기면, Docker Runtime 이 중개자로서 이를 처리하고, 적절히 리소스를 할당해주는 형태이죠.

예를 들어, 컨테이너 내부의 애플리케이션이 System Call 을 통해 커널 기능을 요청하면, Container Runtime 이 이를 받아 Host OS 의 커널에 전달하고, 결과를 다시 Container 로 돌려주는 구조입니다.

조금 더 비유적으로 설명하자면, 이는 마치 Chrome 브라우저 안에서 여러 개의 독립적인 탭을 열어 각각의 작업을 수행하는 것과 유사합니다. 각 탭은 동일한 브라우저 엔진 위에서 실행되지만, 서로 영향을 주지 않고 독립적으로 동작하죠. 컨테이너도 이와 유사하게 하나의 Host OS 커널을 공유하면서도, 마치 별도의 환경처럼 격리된 상태로 동작합니다.


Kubernetes 공식 문서에 나오는 이미지를 참고해보면, 컨테이너 기반 가상화 구조는 다음과 같은 특징을 가집니다.
* Virtual Machine 구조에서는 각 애플리케이션마다 Guest OS, Kernel, Hypervisor까지 별도로 존재합니다.
* Container 구조에서는 모든 컨테이너가 동일한 Host OS 커널을 공유하며, 그 위에서 독립적으로 실행됩니다.


결과적으로, 컨테이너는 다음과 같은 장점을 가집니다.

* 운영체제를 중복 설치할 필요가 없으므로 **자원 효율성이 매우 크게 향상**됩니다. (실제로 VM 대비 2배 이상의 성능 향상을 보이기도 합니다.)
* 컨테이너 이미지를 통해 애플리케이션을 공장처럼 찍어내고 배포할 수 있어 **배포 및 확장성이 우수**합니다.
* 동일한 환경을 어디서든 재현할 수 있으므로, 개발 → 테스트 → 운영 환경 간 일관성이 보장됩니다.

***

# Docker

Docker는 이러한 Container 기술을 활용하여, Application 을 외부 환경으로부터 격리된 채로 실행할 수 있게 해주는 오픈소스 플랫폼입니다.

예를 들어, Windows 에서 잘 실행되던 프로그램이 Linux 에서 갑자기 충돌하는 경우를 생각해봅시다. 서로 다른 OS 환경에서 동작 방식이나 라이브러리, 파일 경로 등이 다르기 때문인데, Docker 는 이런 문제를 해결해 줍니다.

Docker 는 주로 서버나 클라우드 환경에서 사용되며, 다양한 플랫폼에서 동일한 애플리케이션을 안정적으로 실행할 수 있게 해줍니다.

## Docker Container

Docker는 OS 위에 논리적인 실행 영역(Container) 을 생성하고, 이 안에 **Application 과 그 실행에 필요한 환경을 모아 마치 별도의 작은 서버처럼 동작**시킵니다.

Docker Container 는 기술적으로 정확히 말하면, Linux 커널의 기능(네임스페이스, cgroups 등)을 활용하여 Process 를 격리시키는 방식입니다. 이를 통해 하나의 커널 위에 다수의 독립된 컨테이너를 실행할 수 있습니다.

즉, 하나의 물리적 서버 안에서 마치 수십 개의 독립된 서버가 돌아가는 것처럼 만들 수 있는 것이죠.

Docker 외에도 Podman, LXC 등 다양한 Container 가상화 기술이 존재합니다. 각각의 도구는 철학과 사용 목적이 다르지만, Container 의 기본 개념은 동일합니다.

> 물론 이 설명은 개념적 이해를 돕기 위한 것이며, 내부적으로는 더 복잡한 리눅스 커널 기술이 사용됩니다. 하지만 일반 사용자 입장에선 **하나의 OS 안에서 독립된 작은 OS들이 돌아간다** 정도로 이해해도 충분합니다.